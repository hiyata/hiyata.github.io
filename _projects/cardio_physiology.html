---
layout: default
title: Cardio Physio
---

<div class="ap-shell">
  <aside class="ap-side">
    <h1>Cardio Physiology</h1>
    <p class="muted">Tweak channels, drugs, and environment; see the AP reshape in real time.</p>
    <div id="ap-controls"></div>
  </aside>
  <main class="ap-main">
    <div id="ap-app"></div>
  </main>
</div>

<!-- React + ReactDOM (UMD) -->
<script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

<!-- IMPORTANT: react-is must load BEFORE Recharts -->
<script crossorigin src="https://unpkg.com/react-is@18/umd/react-is.development.js"></script>

<!-- Recharts (UMD) -->
<script crossorigin src="https://unpkg.com/recharts/umd/Recharts.js"></script>

<!-- Babel (compile JSX in the browser) -->
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

<style>
  :root{
    --ink:#0f172a; --muted:#64748b; --grid:#e5e7eb; --ring:#cbd5e1;
    --bg:#fafcff; --card:#fff; --accent:#0ea5e9; --accent-soft:#e0f2fe;
    --green:#059669; --red:#dc2626;
  }
  html,body{background:var(--bg);color:var(--ink);font-family:ui-sans-serif,system-ui}
  .ap-shell{max-width:1200px;margin:0 auto;display:grid;grid-template-columns:320px 1fr;gap:18px;padding:16px}
  @media (max-width: 980px){ .ap-shell{grid-template-columns:1fr} .ap-side{position:relative;top:auto} }
  .ap-side{position:sticky; top:12px; align-self:start; background:var(--card); border:1px solid var(--grid);
    border-radius:14px; padding:16px; box-shadow:0 1px 0 rgba(2,6,23,.04)}
  .ap-side h1{font-size:18px; margin:0 0 4px; font-weight:700}
  .ap-side .muted{margin:0 0 12px; color:var(--muted); font-size:14px}
  .ap-main{display:grid; gap:18px}
  .card{background:var(--card); border:1px solid var(--grid); border-radius:14px; padding:12px 14px; box-shadow:0 1px 0 rgba(2,6,23,.04)}
  .row{display:flex; gap:10px; align-items:center}
  .stack{display:flex; flex-direction:column; gap:10px}
  .label{font-size:12px; color:var(--muted)}
  .select, .input, button{border:1px solid var(--grid); border-radius:10px; padding:8px 10px; background:#fff; font-size:14px}
  input[type="range"]{width:100%}
  table{width:100%; border-collapse:collapse; font-size:14px}
  thead th{color:var(--muted); text-align:left; padding:8px 0}
  tbody td{padding:8px 0; border-top:1px solid var(--grid)}
  .legend{display:flex; gap:14px; align-items:center; margin:6px 0 10px; font-size:13px}
  .chip{display:inline-flex; gap:8px; align-items:center; padding:4px 8px; border:1px solid var(--ring); border-radius:999px; background:#fff}
  .line-solid{width:24px; height:3px; background:var(--ink); border-radius:2px}
  .line-dash{width:24px; height:0; border-top:3px dashed #94a3b8}
  .metrics{display:grid; grid-template-columns:repeat(3,1fr); gap:10px}
  .metric{background:var(--accent-soft); border:1px solid var(--ring); border-radius:12px; padding:10px}
  .metric .k{color:var(--muted); font-size:12px}
  .metric .v{font-weight:700}
  .divider{height:1px; background:var(--grid); margin:12px 0}
  .group{border:1px dashed var(--ring); border-radius:12px; padding:10px}
  .group summary{cursor:pointer; list-style:none}
  .group summary::-webkit-details-marker{display:none}
  .group summary .title{font-weight:600; color:var(--ink); font-size:13px}
  .krow{display:grid; grid-template-columns:1fr auto; gap:8px; align-items:center}
  .bar{position:relative;height:8px;background:#f1f5f9;flex:1;overflow:hidden;border-radius:4px}
  .bar .mid{position:absolute;left:50%;top:0;bottom:0;width:1px;background:#cbd5e1}
  .right{margin-left:50%}
  .mini{font-size:12px; color:var(--muted)}
  /* SVG label chip style (drawn in overlay) */
  .phase-chip{paint-order:stroke; stroke:var(--ring); stroke-width:1; rx:6; ry:6}
</style>

{% raw %}
<script type="text/babel" data-presets="env,react">
const {useMemo,useState,Fragment} = React;
const {ResponsiveContainer,LineChart,Line,CartesianGrid,XAxis,YAxis,Tooltip,ReferenceLine,ReferenceDot,Customized} = Recharts;

/* ---------------- Model constants ---------------- */
const BASELINE_PARAMS = { INa:100, ICaL:100, Ito:100, IKr:100, IKs:100, IK1:100, If:100, ICaT:100, IK_ACh:100, NaKATPase:100 };
const CHANNEL_LABELS = {
  INa:"I_Na (fast Na⁺)", ICaL:"I_CaL (L-type Ca²⁺)", Ito:"I_to (transient outward K⁺)",
  IKr:"I_Kr (rapid delayed rectifier K⁺)", IKs:"I_Ks (slow delayed rectifier K⁺)", IK1:"I_K1 (inward rectifier K⁺)",
  If:"I_f (funny)", ICaT:"I_CaT (T-type Ca²⁺)", IK_ACh:"I_K,ACh", NaKATPase:"Na⁺/K⁺-ATPase"
};
const CELL_TYPES = [
  { id:"ventricular", name:"Ventricular Myocyte", uses:{INa:1,ICaL:1,Ito:1,IKr:1,IKs:1,IK1:1,If:0,ICaT:0,IK_ACh:0,NaKATPase:1}},
  { id:"atrial", name:"Atrial Myocyte", uses:{INa:1,ICaL:1,Ito:1,IKr:1,IKs:1,IK1:1,If:0,ICaT:0,IK_ACh:1,NaKATPase:1}},
  { id:"sa", name:"SA Node (Pacemaker)", uses:{INa:0,ICaL:1,Ito:0,IKr:1,IKs:1,IK1:1,If:1,ICaT:1,IK_ACh:1,NaKATPase:1}},
  { id:"purkinje", name:"Purkinje Cell", uses:{INa:1,ICaL:1,Ito:1,IKr:1,IKs:1,IK1:1,If:1,ICaT:1,IK_ACh:0,NaKATPase:1}},
];
const DRUG_PRESETS = {
  "None":{}, "Lidocaine":{INa:50}, "Tetrodotoxin":{INa:5}, "Ranolazine":{INa:70}, "Quinine":{INa:60},
  "Verapamil":{ICaL:40}, "Nifedipine":{ICaL:50}, "Ivabradine":{If:30}, "Acetylcholine ↑":{IK_ACh:150}, "Ouabain":{NaKATPase:40}
};
const ENV_PRESETS = { "None":{}, "Hypokalemia":{IK1:120,IKr:90,IKs:95}, "Hyperkalemia":{IK1:60,INa:80}, "Ischemia":{NaKATPase:50,IK1:70,IKr:120} };

const clamp=(v,lo,hi)=>Math.max(lo,Math.min(hi,v));
const pct=(x)=>clamp(x/100,0,2);

/* ---------------- AP generator ---------------- */
function generateAP(cellId, params){
  const isPacemaker = cellId==="sa";
  let t0=2,t1=8,t2=180,t3=120,t4=100, vmax=30, vrest=-85;
  const kINa=pct(params.INa), kICaL=pct(params.ICaL), kIto=pct(params.Ito),
        kIKr=pct(params.IKr), kIKs=pct(params.IKs), kIK1=pct(params.IK1),
        kIf=pct(params.If), kICaT=pct(params.ICaT), kIK_ACh=pct(params.IK_ACh), kPump=pct(params.NaKATPase);

  if(isPacemaker){
    t1=0;t2=0;t0=15/clamp(kICaL,0.2,2); vmax=20*kICaL;
    const kK=0.6+kIKr*0+0.4*kIKs; // harmless tweak to keep structure similar
    t3=150/clamp(0.6*kIKr+0.4*kIKs,0.2,2);
    const slope=0.4*kIf+0.2*kICaT-0.3*(kIK_ACh-1);
    t4=clamp(220/clamp(1+slope,0.2,3),60,600);
    vrest=-85-3*(kPump-1)+3*(1-kIK1);
  } else {
    t0=clamp(2/clamp(kINa,0.2,2),0.5,6); vmax=30*clamp(kINa,0.4,1.6);
    t1=clamp(8*(0.6+0.4*kIto),2,18);
    const kK=0.6*kIKr+0.4*kIKs; t2=clamp(180*(kICaL/clamp(kK,0.3,2)),40,400);
    t3=clamp(120/clamp(kK,0.3,2),30,300);
    vrest=-85-4*(kPump-1)+5*(1-kIK1);
    if(cellId==="purkinje"){
      const s=0.1*(kIf-1)+0.05*(kICaT-1);
      t4=clamp(100/clamp(1+s,0.3,2),40,300);
    }
  }

  const data=[]; const push=(t,v)=>data.push({t,v});
  const segs=[]; let tA=0; const vTh=isPacemaker?-40:-60;

  if(params && typeof params.__targetCycle==='number'){
    const baseCycle=t4+t0+(isPacemaker?0:(t1+t2))+t3;
    t4=clamp(t4+(params.__targetCycle-baseCycle),20,1200);
  }

  // phase 4
  const n4=Math.max(5,Math.round(t4/2));
  for(let i=0;i<=n4;i++){ const f=i/n4; push(tA+f*t4, vrest+(vTh-vrest)*f); }
  segs.push({phase:4,tStart:tA,tEnd:tA+t4}); tA+=t4;

  // phase 0
  const n0=Math.max(5,Math.round(t0/0.5));
  for(let i=0;i<=n0;i++){ const f=i/n0; push(tA+f*t0, vTh+(vmax-vTh)*(1-Math.pow(1-f,3))); }
  segs.push({phase:0,tStart:tA,tEnd:tA+t0}); tA+=t0;

  if(!isPacemaker){
    // phase 1
    const notch=vmax-20*kIto, n1=Math.max(3,Math.round(t1/0.5));
    for(let i=0;i<=n1;i++){ const f=i/n1; push(tA+f*t1, vmax+(notch-vmax)*f); }
    segs.push({phase:1,tStart:tA,tEnd:tA+t1}); tA+=t1;

    // phase 2
    const plateau=-5+10*(kICaL-(0.6*kIKr+0.4*kIKs)), n2=Math.max(10,Math.round(t2/2));
    for(let i=0;i<=n2;i++){ const f=i/n2; push(tA+f*t2, notch+(plateau-notch)*(1-Math.cos(Math.PI*f))/2); }
    segs.push({phase:2,tStart:tA,tEnd:tA+t2}); tA+=t2;
  }

  // phase 3
  const vEnd=vrest, vStart=isPacemaker? vmax : (data[data.length-1]?.v ?? vmax);
  const n3=Math.max(10,Math.round(t3/2));
  for(let i=0;i<=n3;i++){ const f=i/n3; push(tA+f*t3, vStart+(vEnd-vStart)*(1-Math.cos(Math.PI*f))/2); }
  segs.push({phase:3,tStart:tA,tEnd:tA+t3}); tA+=t3;

  const marks = segs.map(s=>{
    const mid=(s.tStart+s.tEnd)/2; let nearest=data[0];
    for(let i=1;i<data.length;i++){ if(Math.abs(data[i].t-mid)<Math.abs(nearest.t-mid)) nearest=data[i]; }
    return {label:`Phase ${s.phase}`, phase:s.phase, t:nearest.t, v:nearest.v};
  }).filter(m=>!(cellId==="sa" && (m.phase===1||m.phase===2)));

  return {data, marks, segs};
}

function computeMetrics(curve){
  const pts=curve.data||curve; if(!pts.length) return {apd90:0,dvdtMax:0,cycle:0};
  const vrest=pts[0].v; const vmax=pts.reduce((m,p)=>Math.max(m,p.v),-Infinity);
  const v90=vrest+0.1*(vmax-vrest); const up=pts.findIndex(p=>p.v>v90);
  let down=pts.length-1; for(let i=pts.length-1;i>=0;i--){ if(pts[i].v>v90){ down=i; break; } }
  const apd90=(up>=0 && down>up)?(pts[down].t-pts[up].t):0;
  let dvdtMax=0; for(let i=1;i<pts.length;i++){ const dv=pts[i].v-pts[i-1].v; const dt=pts[i].t-pts[i-1].t||1e-6; dvdtMax=Math.max(dvdtMax,dv/dt); }
  const cycle=pts[pts.length-1].t;
  return {apd90:Math.round(apd90), dvdtMax:Math.round(dvdtMax*100)/100, cycle:Math.round(cycle)};
}

/* Phase label layout (overlay, always on top) */
function layoutPhaseMarks(marks){
  if(!marks||!marks.length) return [];
  const sorted=[...marks].sort((a,b)=>a.t-b.t);
  const minGap=28, base=22, extra=12, yMin=-96, yMax=46;

  // Identify P0 and P1
  const P0=sorted.find(m=>m.phase===0);
  const P1=sorted.find(m=>m.phase===1);

  // first pass: time spacing levels
  let lastT=-Infinity, level=0;
  const prelim=sorted.map(m=>{
    if(m.t-lastT<minGap) level=(level+1)%3; else level=0;
    lastT=m.t;
    return {...m,_level:level};
  });

  // enforce P0/P1 separation if close
  if(P0 && P1 && Math.abs(P1.t-P0.t)<60){
    prelim.forEach(m=>{
      if(m.phase===0) m._level = 0; // closer to trace (above)
      if(m.phase===1) m._level = 2; // further (below)
    });
  }

  // convert to displayY with signed offset: P0 above, P1 below
  return prelim.map(m=>{
    const sign = (m.phase===1) ? 1 : -1;
    const offset = base + m._level*extra;
    const desired = m.v + sign*offset;
    const displayY = Math.max(yMin, Math.min(yMax, desired));
    return {...m, displayY};
  });
}

/* Overlay renders on top of chart primitives */
function PhaseOverlay({xScale,yScale,marks}) {
  if(!xScale || !yScale || !marks?.length) return null;
  const padX=6, padY=4, textH=13;
  return (
    <g pointerEvents="none">
      {marks.map((m,i)=>{
        const x = xScale(m.t);
        const y = yScale(m.displayY);
        const title = m.label;
        const w = Math.max(48, title.length*7) + padX*2;
        const h = textH + padY*2;
        return (
          <g key={i} transform={`translate(${x+8},${y - h/2})`}>
            <rect className="phase-chip" width={w} height={h} fill="#fff" rx="6" ry="6"/>
            <text x={padX} y={padY+textH-1} fontSize="12" fill="#334155">{title}</text>
          </g>
        );
      })}
    </g>
  );
}

/* Simple control panel (keeps your draggable sliders) */
function Controls({state, setState, schema}){
  const {name, cellTypeId, preset, envPreset, bpm, params, ko, showBaseline} = state;
  const set = (patch)=>setState({...state, ...patch});
  const clampPct = (v)=>Math.max(0,Math.min(200,Math.round(v)));

  function reset(){
    set({ params:{...BASELINE_PARAMS}, ko:{}, preset:"None", envPreset:"None", bpm:60, name:"My Experiment" });
  }

  return (
    <div className="stack">
      <div className="stack card">
        <div className="stack">
          <label className="label">Session</label>
          <input className="input" value={name} onChange={(e)=>set({name:e.target.value})}/>
        </div>
        <div className="row">
          <div className="stack" style={{flex:1}}>
            <label className="label">Cell type</label>
            <select className="select" value={cellTypeId} onChange={(e)=>set({cellTypeId:e.target.value})}>
              {schema.cells.map(c=><option key={c.id} value={c.id}>{c.name}</option>)}
            </select>
          </div>
          <div className="stack" style={{flex:1}}>
            <label className="label">Drug preset</label>
            <select className="select" value={preset} onChange={(e)=>set({preset:e.target.value})}>
              {Object.keys(schema.drugs).map(p=><option key={p} value={p}>{p}</option>)}
            </select>
          </div>
        </div>
        <div className="row">
          <div className="stack" style={{flex:1}}>
            <label className="label">Environment</label>
            <select className="select" value={envPreset} onChange={(e)=>set({envPreset:e.target.value})}>
              {Object.keys(schema.envs).map(p=><option key={p} value={p}>{p}</option>)}
            </select>
          </div>
          <div className="stack" style={{flex:1}}>
            <label className="label">Pacing (BPM): {bpm}</label>
            <input type="range" min="20" max="220" step="1" value={bpm} onChange={(e)=>set({bpm:+e.target.value})}/>
          </div>
        </div>
        <div className="row" style={{justifyContent:'space-between'}}>
          <label className="label" style={{display:'inline-flex',gap:8,alignItems:'center'}}>
            <input type="checkbox" checked={showBaseline} onChange={(e)=>set({showBaseline:e.target.checked})}/> Show baseline
          </label>
          <button onClick={reset}>Reset</button>
        </div>
      </div>

      {[ // grouped channels
        {label:'Phase 0 (Upstroke)', keys:['INa','ICaL']},
        {label:'Phase 1 (Notch)', keys:['Ito']},
        {label:'Phase 2 (Plateau)', keys:['ICaL','IKr','IKs']},
        {label:'Phase 3 (Repolarization)', keys:['IKr','IKs']},
        {label:'Phase 4 (Rest/Diastolic)', keys:['IK1','If','ICaT','IK_ACh','NaKATPase']},
      ].map(g=>{
        const keys=g.keys.filter(k=>schema.cellUses[cellTypeId][k]);
        if(!keys.length) return null;
        return (
          <details key={g.label} className="group" open>
            <summary><span className="title">{g.label}</span></summary>
            <div className="stack" style={{paddingTop:8}}>
              {keys.map(k=>{
                const disabled = !!ko[k];
                return (
                  <div key={k} className="stack">
                    <div className="krow">
                      <div style={{fontWeight:600, fontSize:14}}>{schema.labels[k]}</div>
                      <label className="mini"><input type="checkbox" checked={!!ko[k]} onChange={(e)=>set({ko:{...ko, [k]:e.target.checked}})}/> KO</label>
                    </div>
                    <div className="row" style={{alignItems:'center'}}>
                      <input type="range" min="0" max="200" step="5" disabled={disabled}
                        value={disabled?0:(params[k]??100)}
                        onChange={(e)=>set({params:{...params, [k]:+e.target.value}})}/>
                      <input className="input" type="number" min="0" max="200" step="5" disabled={disabled}
                        value={disabled?0:(params[k]??100)}
                        onChange={(e)=>set({params:{...params, [k]:clampPct(+e.target.value||0)}})}/>
                      <span className="mini">{disabled?0:(params[k]??100)}%</span>
                    </div>
                  </div>
                );
              })}
            </div>
          </details>
        );
      })}
    </div>
  );
}

function App(){
  const [state,setState]=useState({
    name:"My Experiment", cellTypeId:"ventricular", preset:"None", envPreset:"None",
    bpm:60, params:{...BASELINE_PARAMS}, ko:{}, showBaseline:true
  });

  const cell = useMemo(()=>CELL_TYPES.find(c=>c.id===state.cellTypeId)||CELL_TYPES[0],[state.cellTypeId]);

  const schema = useMemo(()=>({
    cells:CELL_TYPES,
    labels:CHANNEL_LABELS,
    drugs:DRUG_PRESETS,
    envs:ENV_PRESETS,
    cellUses:Object.fromEntries(CELL_TYPES.map(c=>[c.id,c.uses]))
  }),[]);

  // build effective params
  const workingParams=useMemo(()=>{
    const apply=(base,map)=>{ const o={...base}; Object.entries(map).forEach(([k,v])=>{ if(k in o) o[k]=Math.round(o[k]*(v/100));}); return o; };
    const env=apply(state.params, ENV_PRESETS[state.envPreset]||{});
    const drug=apply(env, DRUG_PRESETS[state.preset]||{});
    const out={...drug};
    Object.keys(state.ko).forEach(k=>{ if(state.ko[k]) out[k]=0; });
    Object.keys(out).forEach(k=>{ if(!cell.uses[k]) out[k]=0; });
    out.__targetCycle = clamp(60000/Math.max(20,Math.min(220,state.bpm)),250,3000);
    return out;
  },[state,cell]);

  const baseline=useMemo(()=>generateAP(cell.id,{...BASELINE_PARAMS,__targetCycle:60000/state.bpm}),[cell.id,state.bpm]);
  const modified=useMemo(()=>generateAP(cell.id,workingParams),[cell.id,workingParams]);

  const baseMetrics=useMemo(()=>computeMetrics(baseline),[baseline]);
  const curMetrics=useMemo(()=>computeMetrics(modified),[modified]);

  const laidOutMarks=useMemo(()=>layoutPhaseMarks(modified.marks),[modified.marks]);

  const xAxisLabel={ value:'time (ms)', position:'insideBottomRight', offset:-10 };
  const yAxisLabel={ value:'membrane potential (mV)', angle:-90, position:'insideLeft' };

  // mount controls in sidebar
  React.useEffect(()=>{
    const ctr = document.getElementById('ap-controls');
    if(ctr) ReactDOM.createRoot(ctr).render(<Controls state={state} setState={setState} schema={schema} />);
  },[state, schema]);

  const channelOrder=Object.keys(CHANNEL_LABELS).filter(k=>cell.uses[k]);

  return (
    <div className="stack">
      {/* Chart card */}
      <section className="card">
        <div className="row" style={{justifyContent:'space-between', alignItems:'baseline'}}>
          <div style={{fontWeight:700}}>{state.name}</div>
          <div className="legend">
            <span className="chip"><span className="line-solid"></span> Modified</span>
            <span className="chip"><span className="line-dash"></span> Baseline</span>
          </div>
        </div>

        <div style={{width:'100%', height:460, marginTop:8}}>
          <ResponsiveContainer>
            <LineChart data={modified.data} margin={{top:8,right:24,bottom:20,left:12}}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis type="number" dataKey="t" domain={[0,'dataMax']} tickCount={10} label={xAxisLabel}/>
              <YAxis domain={[-100,50]} tickCount={8} label={yAxisLabel}/>
              <Tooltip
                formatter={(v)=>`${Number(v).toFixed(1)} mV`}
                labelFormatter={(l)=>`${Number(l).toFixed(1)} ms`}
                contentStyle={{borderRadius:10,border:'1px solid var(--ring)'}}
              />
              {state.showBaseline && (
                <Line dot={false} type="monotone" dataKey="v" data={baseline.data} name="Baseline"
                      stroke="#94a3b8" strokeWidth={2} strokeDasharray="6 4"/>
              )}
              <Line dot={false} type="monotone" dataKey="v" data={modified.data} name="Modified" stroke="#0f172a" strokeWidth={3}/>
              <ReferenceLine y={-85} stroke="#e5e7eb"/>

              {/* draw stems, then overlay labels */}
              {laidOutMarks.map((m,i)=>(
                <ReferenceLine key={'stem'+i} isFront segment={[{x:m.t,y:m.v},{x:m.t,y:m.displayY}]} stroke="#cbd5e1"/>
              ))}
              <Customized component={({xAxisMap,yAxisMap,width,height,offset})=>{
                const xScale = Object.values(xAxisMap||{})[0]?.scale;
                const yScale = Object.values(yAxisMap||{})[0]?.scale;
                return <PhaseOverlay xScale={xScale} yScale={yScale} marks={laidOutMarks} />;
              }}/>
            </LineChart>
          </ResponsiveContainer>
        </div>

        <div className="metrics" style={{marginTop:12}}>
          <div className="metric">
            <div className="k">APD90</div>
            <div className="v">{curMetrics.apd90} ms</div>
            <div className="mini" style={{color:(curMetrics.apd90-baseMetrics.apd90)>=0?'var(--green)':'var(--red)'}}>
              {(curMetrics.apd90-baseMetrics.apd90)>=0?'↑':'↓'} {Math.abs(curMetrics.apd90-baseMetrics.apd90)} vs baseline
            </div>
          </div>
          <div className="metric">
            <div className="k">dV/dtₘₐₓ</div>
            <div className="v">{curMetrics.dvdtMax} mV/ms</div>
            <div className="mini" style={{color:(curMetrics.dvdtMax-baseMetrics.dvdtMax)>=0?'var(--green)':'var(--red)'}}>
              {(curMetrics.dvdtMax-baseMetrics.dvdtMax)>=0?'↑':'↓'} {Math.abs((curMetrics.dvdtMax-baseMetrics.dvdtMax).toFixed(2))} vs baseline
            </div>
          </div>
          <div className="metric">
            <div className="k">Cycle</div>
            <div className="v">{curMetrics.cycle} ms</div>
            <div className="mini" style={{color:(curMetrics.cycle-baseMetrics.cycle)>=0?'var(--green)':'var(--red)'}}>
              {(curMetrics.cycle-baseMetrics.cycle)>=0?'↑':'↓'} {Math.abs(curMetrics.cycle-baseMetrics.cycle)} vs baseline
            </div>
          </div>
        </div>

        <div className="divider"></div>

        {/* Sensitivity */}
        <div className="stack">
          {channelOrder.map(k=>{
            const apply=(b,m)=>{const o={...b};Object.entries(m).forEach(([kk,v])=>{if(kk in o) o[kk]=Math.round(o[kk]*(v/100));});return o;};
            const env=apply(state.params,ENV_PRESETS[state.envPreset]||{}); const drug=apply(env,DRUG_PRESETS[state.preset]||{});
            const common={...drug}; Object.keys(state.ko).forEach(x=>{ if(state.ko[x]) common[x]=0; }); common.__targetCycle=60000/state.bpm;
            const metrics=p=>computeMetrics(generateAP(state.cellTypeId,p));
            const m0=metrics(common);
            const up=metrics({...common,[k]:clamp((common[k]??100)*1.2,0,200)});
            const dn=metrics({...common,[k]:clamp((common[k]??100)*0.8,0,200)});
            const dUp=up.apd90-m0.apd90, dDn=dn.apd90-m0.apd90;
            return (
              <div key={k} className="row" style={{alignItems:'center'}}>
                <div style={{width:240,whiteSpace:'nowrap',overflow:'hidden',textOverflow:'ellipsis'}}>{CHANNEL_LABELS[k]}</div>
                <div className="bar" style={{flex:1}}>
                  <div className="mid"></div>
                  <div style={{width:Math.min(100,Math.abs(dDn))+'%', height:'100%', background:dDn<0?'var(--green)':'var(--red)'}}></div>
                  <div className="right" style={{width:Math.min(100,Math.abs(dUp))+'%', height:'100%', background:dUp>0?'var(--green)':'var(--red)'}}></div>
                </div>
                <div className="mini" style={{width:220,textAlign:'right',fontFeatureSettings:'tnum'}}>
                  ΔAPD: −20% {Math.round(dDn)} / +20% {Math.round(dUp)} ms
                </div>
              </div>
            );
          })}
        </div>

        <div className="divider"></div>

        {/* Parameters table */}
        <section>
          <div className="label" style={{fontWeight:700, color:'var(--ink)'}}>Parameters</div>
          <table>
            <thead><tr><th>Channel</th><th>% of baseline</th><th>KO</th></tr></thead>
            <tbody>
              {channelOrder.map(k=>(
                <tr key={k}><td>{CHANNEL_LABELS[k]}</td><td>{(state.ko[k]?0:state.params[k])}%</td><td>{state.ko[k]?'Yes':'No'}</td></tr>
              ))}
            </tbody>
          </table>
        </section>
      </section>
    </div>
  );
}

ReactDOM.createRoot(document.getElementById('ap-app')).render(<App/>);
</script>
{% endraw %}
