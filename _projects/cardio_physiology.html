---
layout: default
title: Cardio Physio
---

<div id="ap-app" style="max-width:1400px;margin:0 auto;padding:1.25rem"></div>

<!-- React + ReactDOM (UMD) -->
<script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
<script crossorigin src="https://unpkg.com/react-is@18/umd/react-is.development.js"></script>

<!-- Recharts (UMD) -->
<script crossorigin src="https://unpkg.com/recharts/umd/Recharts.js"></script>

<!-- Babel (compile JSX in the browser) -->
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

<style>
  :root{--ink:#0f172a;--muted:#64748b;--grid:#e5e7eb;--green:#059669;--red:#dc2626;--blue:#2563eb;}
  body{color:var(--ink)}
  .wrap{display:grid;grid-template-columns:1fr;gap:24px;max-width:100%;}
  @media(min-width:1024px){.wrap{grid-template-columns:minmax(300px, 400px) 1fr;gap:32px}}
  .section h2{font:600 12px/1.1 ui-sans-serif,system-ui;letter-spacing:.08em;text-transform:uppercase;color:var(--muted);margin:0 0 8px}
  .stack{display:flex;flex-direction:column;gap:12px}
  .row{display:flex;gap:12px;align-items:center}
  .flex1{flex:1}
  .field{display:flex;flex-direction:column;gap:6px}
  .label{font-size:12px;color:var(--muted)}
  input[type="range"]{width:100%}
  input[type="number"],select,button{border:1px solid var(--grid);border-radius:6px;padding:6px 8px;font-size:14px}
  button{cursor:pointer;background:#fff}
  button:hover{background:#f8fafc}
  button.primary{background:var(--blue);color:white;font-weight:600}
  button.primary:hover{background:#1d4ed8}
  .legend{display:flex;gap:16px;align-items:center;margin:6px 0 10px;font-size:14px}
  .pill{display:inline-flex;gap:8px;align-items:center}
  .pill .line{width:32px;height:2px;background:var(--ink);display:inline-block}
  .pill .dash{width:32px;height:0;border-top:2px dashed #94a3b8;display:inline-block}
  .metrics{display:grid;grid-template-columns:repeat(3,1fr);gap:12px}
  .metric .k{color:var(--muted);font-size:12px}
  .metric .v{font-weight:600}
  .metric .d{font-size:12px}
  .divider{height:1px;background:var(--grid);margin:12px 0}
  .mode-toggle{display:flex;gap:0;border:1px solid var(--grid);border-radius:6px;overflow:hidden;margin-bottom:16px}
  .mode-toggle button{border:none;border-radius:0;padding:8px 16px;background:white}
  .mode-toggle button.active{background:var(--blue);color:white}
  .quiz-option{padding:12px;border:2px solid var(--grid);border-radius:6px;cursor:pointer;transition:all 0.2s}
  .quiz-option:hover{border-color:var(--blue);background:#f8fafc}
  .quiz-option.correct{border-color:var(--green);background:#f0fdf4}
  .quiz-option.incorrect{border-color:var(--red);background:#fef2f2}
  .quiz-option.disabled{cursor:not-allowed;opacity:0.6}
  .score-display{display:flex;gap:16px;padding:12px;background:#f8fafc;border-radius:6px;font-weight:600}
  .badge{display:inline-block;padding:4px 8px;border-radius:4px;font-size:12px;font-weight:600;margin-left:8px}
  .badge.ko{background:#fef2f2;color:var(--red)}
  .badge.increase{background:#f0fdf4;color:var(--green)}
</style>

{% raw %}
<script type="text/babel" data-presets="env,react">
const {useMemo,useState,useRef} = React;
const {LineChart,Line,CartesianGrid,XAxis,YAxis,Tooltip,ReferenceLine,ResponsiveContainer} = Recharts;

/* ---------------- Model constants ---------------- */
const BASELINE_PARAMS = { INa:100, ICaL:100, Ito:100, IKr:100, IKs:100, IK1:100, If:100, ICaT:100, IK_ACh:100, NaKATPase:100 };
const CHANNEL_LABELS = {
  INa:"I_Na (fast Na⁺)", ICaL:"I_CaL (L-type Ca²⁺)", Ito:"I_to (transient outward K⁺)",
  IKr:"I_Kr (rapid delayed rectifier K⁺)", IKs:"I_Ks (slow delayed rectifier K⁺)", IK1:"I_K1 (inward rectifier K⁺)",
  If:"I_f (funny)", ICaT:"I_CaT (T-type Ca²⁺)", IK_ACh:"I_K,ACh", NaKATPase:"Na⁺/K⁺-ATPase"
};
const SIMILAR_CHANNEL_GROUPS = [['IKr','IKs'], ['ICaL','ICaT'], ['If','ICaT']];
const CELL_TYPES = [
  { id:"ventricular", name:"Ventricular Myocyte", uses:{INa:1,ICaL:1,Ito:1,IKr:1,IKs:1,IK1:1,If:0,ICaT:0,IK_ACh:0,NaKATPase:1}},
  { id:"atrial", name:"Atrial Myocyte", uses:{INa:1,ICaL:1,Ito:1,IKr:1,IKs:1,IK1:1,If:0,ICaT:0,IK_ACh:1,NaKATPase:1}},
  { id:"sa", name:"SA Node (Pacemaker)", uses:{INa:0,ICaL:1,Ito:0,IKr:1,IKs:1,IK1:1,If:1,ICaT:1,IK_ACh:1,NaKATPase:1}},
  { id:"purkinje", name:"Purkinje Cell", uses:{INa:1,ICaL:1,Ito:1,IKr:1,IKs:1,IK1:1,If:1,ICaT:1,IK_ACh:0,NaKATPase:1}},
];

// (Same drug/environment presets as your original)
const DRUG_PRESETS = {
  "None":{},
  "Isoproterenol (β agonist)":{ ICaL:130, IKs:120, If:125 },
  "Dobutamine (β₁ agonist)":{ ICaL:125, IKs:115, If:115 },
  "Propranolol (β blocker)":{ ICaL:80, IKs:90, If:90 },
  "Atenolol (β₁ blocker)":{ ICaL:85, IKs:90, If:90 },
  "Metoprolol (β₁ blocker)":{ ICaL:85, IKs:90, If:90 },
  "Esmolol (β₁ blocker, short)":{ ICaL:85, IKs:90, If:90 },
  "Adenosine (A₁ agonist)":{ IK_ACh:150, If:85, ICaL:90 },
  "Atropine (M₂ antagonist)":{ IK_ACh:70, If:110 },
  "Scopolamine (M₂ antagonist)":{ IK_ACh:70, If:110 },
  "Physostigmine (AChE inhibitor)":{ IK_ACh:130, If:90 },
  "Ivabradine (If blocker)":{ If:40 },
  "Verapamil (L-type CCB)":{ ICaL:50 },
  "Diltiazem (L-type CCB)":{ ICaL:60 },
  "Nifedipine (DHP CCB)":{ ICaL:60 },
  "Amlodipine (DHP CCB)":{ ICaL:60 },
  "Lidocaine (Class IB)":{ INa:60 },
  "Mexiletine (Class IB)":{ INa:60 },
  "Procainamide (Class IA)":{ INa:70, IKr:85 },
  "Disopyramide (Class IA)":{ INa:70, IKr:90 },
  "Quinidine (Class IA)":{ INa:70, IKr:85 },
  "Flecainide (Class IC)":{ INa:50 },
  "Ranolazine (late INa)":{ INa:70 },
  "Amiodarone (multi-channel)":{ INa:70, ICaL:70, IKr:70, IKs:85 },
  "Ibutilide (IKr blocker)":{ IKr:60 },
  "Dofetilide (IKr blocker)":{ IKr:50 },
  "Milrinone (PDE3 inhibitor)":{ ICaL:120, IKs:110, If:110 },
  "Digoxin (cardiac glycoside)":{ NaKATPase:40 },
  "Reserpine (VMAT inhibitor)":{ ICaL:95, IKs:95, If:95 },
  "Guanethidine (adrenergic depletor)":{ ICaL:95, IKs:95, If:95 },
};
const ENV_PRESETS = { "None":{}, "Hypokalemia":{IK1:120,IKr:90,IKs:95}, "Hyperkalemia":{IK1:60,INa:80}, "Ischemia":{NaKATPase:50,IK1:70,IKr:120} };

const clamp=(v,lo,hi)=>Math.max(lo,Math.min(hi,v));
const pct=(x)=>clamp(x/100,0,2);

/* --------------------------------------------------------------------
   NEW: Conductance-based toy engine (physiology-aligned, still tiny)
-------------------------------------------------------------------- */
function cardSim({cellId="ventricular", params={}, bpm=60, cycles=1}){
  const scale = (name, def)=> clamp(((params?.[name]??100)/100)*def, 0, 2*def);

  // Reversal potentials (mV) and capacitance
  const Cm=1.0, ENa=60, EK=-90, ECa=60, Eleak=-60;

  // Cell-type defaults (mS/cm^2)
  let gNa   = scale("INa",   cellId==="sa"?0:12);
  let gCaL  = scale("ICaL",  1.6);
  let gto   = scale("Ito",   cellId==="sa"?0:0.35);
  let gKr   = scale("IKr",   0.5);
  let gKs   = scale("IKs",   0.2);
  let gK1   = scale("IK1",   cellId==="sa"?0.15:1.2);
  let gf    = scale("If",    (cellId==="sa"||cellId==="purkinje")?0.25:0);
  let gCaT  = scale("ICaT",  (cellId==="sa"||cellId==="purkinje")?0.12:0);
  let gACh  = scale("IK_ACh",(cellId==="atrial"||cellId==="sa")?0.1:0);
  const gLeak=0.02;

  // Simple gating steady-states and time constants
  const sig=(x,x0,k)=>1/(1+Math.exp((x0-x)/k));
  const m_inf=V=>sig(V,-35,7);           // Na activation (instantaneous)
  const h_inf=V=>sig(-V,-60,6),   tau_h=V=>1 + 4*sig(V,-40,7);
  const d_inf=V=>sig(V,-15,6),    f_inf=V=>sig(-V,-25,6), tau_f=V=>20 + 60*sig(V,-10,7);
  const a_inf=V=>sig(V,-30,7),    b_inf=V=>sig(-V,-65,6), tau_b=V=>8 + 20*sig(V,-50,7);
  const n_inf=V=>sig(V,-20,6),    tau_n=V=>50/(1+Math.exp((V+25)/10)) + 10;
  const r_inf=V=>sig(-V,-20,6),   tau_r=V=>8 + 30*sig(V,-40,7);
  const s_inf=V=>sig(-V,-80,7),   tau_s=V=>70 + 200*sig(V,-90,7);
  const rectK1=V=>1/(1+Math.exp((V+75)/5)); // inward rectifier factor

  // Pacing: non-nodal cells get a brief stimulus; SA node self-fires
  const CL = params.__targetCycle ? clamp(params.__targetCycle,250,3000)
                                  : clamp(60000/Math.max(20,Math.min(220,bpm)),250,3000);
  const stimAmp = 60;   // µA/cm^2
  const stimMs  = 1.0;  // ms width
  const Iapp = (t)=> (cellId==="sa" ? 0 : ((t%CL)<stimMs ? -stimAmp : 0));

  // Integrate
  const dt=0.02, T=cycles*CL;
  let V=(cellId==="sa"?-60:-85);
  let h=h_inf(V), n=n_inf(V), f=f_inf(V), r=r_inf(V), s=s_inf(V), b=b_inf(V), a=a_inf(V);

  const data=[];
  for(let t=0; t<=T; t+=dt){
    // Ionic currents (outward positive)
    const INa  = gNa  * Math.pow(m_inf(V),3) * h * (V-ENa);
    const ICaL = gCaL * d_inf(V) * f * (V-ECa);
    const ICaT = gCaT * a * b * (V-ECa);
    const Ito  = gto  * r * (V-EK);
    const IKr  = gKr  * n * (V-EK);
    const IKs  = gKs  * n * (V-EK);
    const IK1  = gK1  * rectK1(V) * (V-EK);
    const IACh = gACh * (V-EK);
    // funny current: inward (Na/K mixed) driving toward ~ -20 mV
    const Ef=-20, If = gf * s * (V - Ef);
    const Ileak = gLeak*(V-Eleak);

    const Iion = INa + ICaL + ICaT + Ito + IKr + IKs + IK1 + IACh + If + Ileak;
    V += dt * (-(Iion) + Iapp(t)) / Cm;

    // update gates
    h += dt*((h_inf(V)-h)/tau_h(V));
    n += dt*((n_inf(V)-n)/tau_n(V));
    f += dt*((f_inf(V)-f)/tau_f(V));
    r += dt*((r_inf(V)-r)/tau_r(V));
    s += dt*((s_inf(V)-s)/tau_s(V));
    b += dt*((b_inf(V)-b)/tau_b(V));
    a  = a_inf(V); // fast

    if((t%1)===0) data.push({t:+t.toFixed(2), v:+V.toFixed(3)});
  }

  // One minimal mark so your UI still shows a label
  const segs=[{phase:4,tStart:0,tEnd:data[data.length-1]?.t||0}];
  const iMid=Math.floor(data.length*0.7);
  const marks=[{label:'AP', t:data[iMid]?.t||0, v:data[iMid]?.v??-70}];
  return {data, segs, marks};
}

/* ---------------- Metrics (unchanged) ---------------- */
function computeMetrics(curve){
  const pts=curve.data||curve; if(!pts.length) return {apd90:0,dvdtMax:0,cycle:0};
  const vrest=pts[0].v; const vmax=pts.reduce((m,p)=>Math.max(m,p.v),-Infinity);
  const v90=vrest+0.1*(vmax-vrest); const up=pts.findIndex(p=>p.v>v90);
  let down=pts.length-1; for(let i=pts.length-1;i>=0;i--){ if(pts[i].v>v90){ down=i; break; } }
  const apd90=(up>=0 && down>up)?(pts[down].t-pts[up].t):0;
  let dvdtMax=0; for(let i=1;i<pts.length;i++){ const dv=pts[i].v-pts[i-1].v; const dt=pts[i].t-pts[i-1].t||1e-6; dvdtMax=Math.max(dv/dt,dvdtMax); }
  const cycle=pts[pts.length-1].t;
  return {apd90:Math.round(apd90), dvdtMax:Math.round(dvdtMax*100)/100, cycle:Math.round(cycle)};
}

/* ---------------- Phase groups (UI labels kept) ---------------- */
const PHASE_GROUPS=[
  {label:'Phase 0 (Upstroke)', keys:['INa','ICaL']},
  {label:'Phase 1 (Notch)', keys:['Ito']},
  {label:'Phase 2 (Plateau)', keys:['ICaL','IKr','IKs']},
  {label:'Phase 3 (Repolarization)', keys:['IKr','IKs']},
  {label:'Phase 4 (Rest/Diastolic)', keys:['IK1','If','ICaT','IK_ACh','NaKATPase']},
];

function areSimilarChannels(ch1, ch2){
  for(const group of SIMILAR_CHANNEL_GROUPS){
    if(group.includes(ch1) && group.includes(ch2)) return true;
  }
  return false;
}

/* ---------------- ECG synthesizer (unchanged) ---------------- */
function gaussian(x, mu, sigma, amp){ const z=(x-mu)/sigma; return amp*Math.exp(-0.5*z*z); }
function generateECGSeries({rr, pr, qrs, qt, beats=3, fs=1000}){
  rr = clamp(rr, 300, 2000);  pr = clamp(pr, 100, 260);
  qrs = clamp(qrs, 70, 160);  qt = clamp(qt, 280, 520);
  const dt=1000/fs, oneBeat=[], nBeat=Math.round(rr/dt);
  for(let i=0;i<nBeat;i++){
    const tb=i*dt;
    const pC=Math.max(0.11*rr, pr-0.5*qrs);
    const qrsC=pr;
    const tStart=qrsC+qrs;
    const tC=tStart+0.45*(qt-qrs);
    const pS=0.05*rr; const qS=0.12*qrs, rS=0.09*qrs, sS=0.10*qrs; const tS=0.22*(qt-qrs);
    let v=0;
    v+=gaussian(tb,pC,            pS,  0.12);
    v+=gaussian(tb,qrsC-0.20*qrs, qS, -0.25);
    v+=gaussian(tb,qrsC,          rS,  1.00);
    v+=gaussian(tb,qrsC+0.25*qrs, sS, -0.35);
    v+=gaussian(tb,tC,            tS,  0.35);
    oneBeat.push(v);
  }
  const mean = oneBeat.reduce((a,b)=>a+b,0)/oneBeat.length;
  for(let i=0;i<oneBeat.length;i++) oneBeat[i]-=mean;
  const data=[]; for(let b=0;b<beats;b++){ for(let i=0;i<nBeat;i++){ const t_s=(b*rr + i*dt)/1000; data.push({t:+t_s.toFixed(3), v:oneBeat[i]}); } }
  return data;
}

/* ---------------- Quiz Mode (unchanged UI) ---------------- */
function QuizMode(){
  const [cellTypeId, setCellTypeId] = useState("ventricular");
  const [currentQuestion, setCurrentQuestion] = useState(null);
  const [selectedAnswer, setSelectedAnswer] = useState(null);
  const [showResult, setShowResult] = useState(false);
  const [score, setScore] = useState(0);
  const [questionsAnswered, setQuestionsAnswered] = useState(0);
  const lastTargetRef = useRef(null);

  const cell = useMemo(()=>CELL_TYPES.find(c=>c.id===cellTypeId)||CELL_TYPES[0],[cellTypeId]);
  const availableChannels = useMemo(()=>Object.keys(CHANNEL_LABELS).filter(k=>cell.uses[k]),[cell]);

  const generateQuestion = ()=>{
    let targetChannel;
    const eligible = availableChannels.filter(ch=>ch!==lastTargetRef.current);
    targetChannel = eligible.length? eligible[Math.floor(Math.random()*eligible.length)] : availableChannels[0];
    lastTargetRef.current = targetChannel;

    const isKO = Math.random()<0.5;
    const modValue = isKO?0:200;
    const modType = isKO?'knockout':'increase';

    const modParams = {...BASELINE_PARAMS, [targetChannel]:modValue};
    const baselineParams = {...BASELINE_PARAMS};

    const wrong = availableChannels
      .filter(c=>c!==targetChannel && !areSimilarChannels(c,targetChannel))
      .sort(()=>Math.random()-0.5).slice(0,3);
    if(wrong.length<3){
      const remain = availableChannels.filter(c=>c!==targetChannel && !wrong.includes(c)).sort(()=>Math.random()-0.5);
      wrong.push(...remain.slice(0,3-wrong.length));
    }
    const options=[targetChannel,...wrong].sort(()=>Math.random()-0.5);

    return {
      targetChannel, modType, modValue, options,
      baseline: cardSim({cellId:cellTypeId, params:baselineParams, bpm:60, cycles:(cellTypeId==='sa'?3:1)}),
      modified: cardSim({cellId:cellTypeId, params:modParams, bpm:60, cycles:(cellTypeId==='sa'?3:1)})
    };
  };

  useMemo(()=>{ if(!currentQuestion) setCurrentQuestion(generateQuestion()); },[cellTypeId,currentQuestion,availableChannels]);

  const handleAnswer=(ans)=>{ if(showResult) return;
    setSelectedAnswer(ans); setShowResult(true); setQuestionsAnswered(q=>q+1);
    if(ans===currentQuestion.targetChannel) setScore(s=>s+1);
  };

  const nextQuestion=()=>{ setCurrentQuestion(generateQuestion()); setSelectedAnswer(null); setShowResult(false); };
  const resetQuiz=()=>{ setScore(0); setQuestionsAnswered(0); lastTargetRef.current=null; setCurrentQuestion(generateQuestion()); setSelectedAnswer(null); setShowResult(false); };

  if(!currentQuestion) return <div>Loading...</div>;
  const xAxisLabel={ value:'time (ms)', position:'insideBottomRight', offset:-10 };
  const yAxisLabel={ value:'membrane potential (mV)', angle:-90, position:'insideLeft' };

  const base={data:currentQuestion.baseline, segs:[{phase:4,tStart:0,tEnd:currentQuestion.baseline.at(-1)?.t||0}], marks:[]};
  const mod ={data:currentQuestion.modified, segs:[{phase:4,tStart:0,tEnd:currentQuestion.modified.at(-1)?.t||0}], marks:[]};

  return (
    <div className="wrap">
      <section className="section">
        <h2>Quiz Settings</h2>
        <div className="stack">
          <div className="field">
            <label className="label">Cell type</label>
            <select value={cellTypeId} onChange={(e)=>{setCellTypeId(e.target.value);lastTargetRef.current=null;setCurrentQuestion(null);}} disabled={showResult}>
              {CELL_TYPES.map(c=>
                <option key={c.id} value={c.id}>{c.name}</option>
              )}
            </select>
          </div>

          <div className="divider"></div>

          <div className="score-display">
            <div>Score: {score}/{questionsAnswered}</div>
            <div>{questionsAnswered>0 ? `${Math.round(score/questionsAnswered*100)}%` : '—'}</div>
          </div>

          <button onClick={resetQuiz}>Reset Quiz</button>

          <div className="divider"></div>

          <div>
            <h3 style={{marginBottom:12,fontSize:14,fontWeight:600}}>
              Which ion channel/transporter was 
              <span className={`badge ${currentQuestion.modType==='knockout'?'ko':'increase'}`}>
                {currentQuestion.modType==='knockout' ? 'KNOCKED OUT (0%)' : 'INCREASED (200%)'}
              </span>
              ?
            </h3>
            <div className="stack">
              {currentQuestion.options.map(opt=>(
                <button key={opt}
                        className={`quiz-option ${showResult ? (opt===currentQuestion.targetChannel ? 'correct' : opt===selectedAnswer ? 'incorrect' : '') : ''} ${showResult ? 'disabled' : ''}`}
                        onClick={()=>handleAnswer(opt)} disabled={showResult}>
                  {CHANNEL_LABELS[opt]}
                </button>
              ))}
            </div>
          </div>

          {showResult && (
            <>
              <div style={{padding:12,background:selectedAnswer===currentQuestion.targetChannel?'#f0fdf4':'#fef2f2',borderRadius:6,fontWeight:600}}>
                {selectedAnswer===currentQuestion.targetChannel ? '✓ Correct!' : `✗ Incorrect. The answer was: ${CHANNEL_LABELS[currentQuestion.targetChannel]}`}
              </div>
              <button className="primary" onClick={nextQuestion}>Next Question</button>
            </>
          )}
        </div>
      </section>

      <section className="section">
        <h2>Action Potential</h2>
        <div className="legend">
          <span className="pill"><span className="line"></span> Modified ({currentQuestion.modType})</span>
          <span className="pill"><span className="dash"></span> Baseline</span>
        </div>
        <div style={{width: '100%'}}>
          <ResponsiveContainer width="100%" height={420}>
            <LineChart data={mod.data} margin={{top:8,right:40,bottom:20,left:20}}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis type="number" dataKey="t" domain={[0,'dataMax']} tickCount={10} label={xAxisLabel}/>
              <YAxis domain={[-100,50]} tickCount={8} label={yAxisLabel}/>
              <Tooltip formatter={(v)=>`${Number(v).toFixed(1)} mV`} labelFormatter={(l)=>`${Number(l).toFixed(1)} ms`} />
              <Line dot={false} type="monotone" dataKey="v" data={base.data} name="Baseline" stroke="#94a3b8" strokeWidth={2} strokeDasharray="6 4"/>
              <Line dot={false} type="monotone" dataKey="v" data={mod.data} name="Modified" stroke="#0f172a" strokeWidth={3}/>
              <ReferenceLine y={-85} stroke="#e5e7eb"/>
            </LineChart>
          </ResponsiveContainer>
        </div>
      </section>
    </div>
  );
}

/* ---------------- Explore Mode (minor glue to pass cycle length) ---------------- */
function ExploreMode(){
  const [cellTypeId,setCellTypeId]=useState("ventricular");
  const [params,setParams]=useState({...BASELINE_PARAMS});
  const [ko,setKo]=useState({});
  const [preset,setPreset]=useState("None");
  const [envPreset,setEnvPreset]=useState("None");
  const [showBaseline,setShowBaseline]=useState(true);
  const [bpm,setBpm]=useState(60);

  const cell=useMemo(()=>CELL_TYPES.find(c=>c.id===cellTypeId)||CELL_TYPES[0],[cellTypeId]);

  const buildParamsFor=(id, useCurrent=true)=>{
    const base = useCurrent ? {...params} : {...BASELINE_PARAMS};
    const apply=(obj,map)=>{ const out={...obj}; Object.entries(map).forEach(([k,v])=>{ if(k in out) out[k]=Math.round(out[k]*(v/100));}); return out; };
    const env = useCurrent ? (ENV_PRESETS[envPreset]||{}) : {};
    const drug = useCurrent ? (DRUG_PRESETS[preset]||{}) : {};
    const out = apply(apply(base,env),drug);
    if(useCurrent){ Object.keys(ko).forEach(k=>{ if(ko[k]) out[k]=0; }); }
    const mask=CELL_TYPES.find(c=>c.id===id)?.uses||{};
    Object.keys(out).forEach(k=>{ if(!mask[k]) out[k]=0; });
    if(id!=='sa' && id!=='purkinje'){ out.__targetCycle = clamp(60000/Math.max(20,Math.min(220,bpm)),250,3000); }
    return out;
  };

  const baseline=useMemo(()=>{
    const base={...BASELINE_PARAMS};
    if(cell.id!=='sa' && cell.id!=='purkinje'){ base.__targetCycle = clamp(60000/Math.max(20,Math.min(220,bpm)),250,3000); }
    return cardSim({cellId:cell.id, params:base, bpm, cycles:(cell.id==='sa'?3:1)});
  },[cell.id,bpm]);

  const modified=useMemo(()=>cardSim({cellId:cell.id, params:buildParamsFor(cell.id,true), bpm, cycles:(cell.id==='sa'?3:1)}),[cell.id,params,preset,envPreset,ko,bpm]);

  const baseMetrics=useMemo(()=>computeMetrics({data:baseline}),[baseline]);
  const curMetrics =useMemo(()=>computeMetrics({data:modified}),[modified]);

  const intervalsFromParams=(useCurrent)=>{
    const saAP   = cardSim({cellId:'sa', params:buildParamsFor('sa',useCurrent), bpm, cycles:3});
    const atrAP  = cardSim({cellId:'atrial', params:buildParamsFor('atrial',useCurrent), bpm, cycles:1});
    const ventAP = cardSim({cellId:'ventricular', params:buildParamsFor('ventricular',useCurrent), bpm, cycles:1});
    const saM=computeMetrics({data:saAP}), atrM=computeMetrics({data:atrAP}), ventM=computeMetrics({data:ventAP});

    const rr_ms = (saM.cycle>0? saM.cycle : clamp(60000/Math.max(20,Math.min(220,bpm)),250,3000));
    const kICaL_atrial = pct((buildParamsFor('atrial',useCurrent).ICaL??100));
    const kIKAch_atrial= pct((buildParamsFor('atrial',useCurrent).IK_ACh??100));
    const pr_ms = clamp(160 + 40*(1-kICaL_atrial) + 30*(kIKAch_atrial-1), 100, 260);
    const qrs_ms= clamp(90 + 6*(12 - clamp(ventM.dvdtMax,2,20)), 70, 160);
    const qt_ms = clamp(ventM.apd90 + 40, 280, 520);
    return {rr:rr_ms, pr:pr_ms, qrs:qrs_ms, qt:qt_ms};
  };

  const intsMod  = useMemo(()=>intervalsFromParams(true), [params,preset,envPreset,ko,bpm]);
  const intsBase = useMemo(()=>intervalsFromParams(false),[bpm]);

  const ecgData     = useMemo(()=>generateECGSeries({...intsMod, beats:3, fs:1000}),   [intsMod.rr,intsMod.pr,intsMod.qrs,intsMod.qt]);
  const ecgBaseline = useMemo(()=>generateECGSeries({...intsBase, beats:3, fs:1000}), [intsBase.rr,intsBase.pr,intsBase.qrs,intsBase.qt]);

  const xAxisLabel={ value:'time (ms)', position:'insideBottomRight', offset:-10 };
  const yAxisLabel={ value:'membrane potential (mV)', angle:-90, position:'insideLeft' };

  function resetAll(){ setParams({...BASELINE_PARAMS}); setKo({}); setPreset("None"); setEnvPreset("None"); setBpm(60); }

  return (
    <div className="wrap">
      {/* Controls */}
      <section className="section">
        <h2>Controls</h2>
        <div className="stack">
          <div className="row">
            <div className="field flex1">
              <label className="label">Cell type</label>
              <select value={cellTypeId} onChange={(e)=>setCellTypeId(e.target.value)}>
                {CELL_TYPES.map(c=>
                  <option key={c.id} value={c.id}>{c.name}</option>
                )}
              </select>
            </div>
            <div className="field flex1">
              <label className="label">Drug preset</label>
              <select value={preset} onChange={(e)=>setPreset(e.target.value)}>
                {Object.keys(DRUG_PRESETS).map(p=>
                  <option key={p} value={p}>{p}</option>
                )}
              </select>
            </div>
          </div>
          <div className="row">
            <div className="field flex1">
              <label className="label">Environment</label>
              <select value={envPreset} onChange={(e)=>setEnvPreset(e.target.value)}>
                {Object.keys(ENV_PRESETS).map(p=>
                  <option key={p} value={p}>{p}</option>
                )}
              </select>
            </div>
            <div className="field flex1">
              <label className="label">Pacing (BPM): {bpm}</label>
              <input type="range" min="20" max="220" step="1" value={bpm} onChange={(e)=>setBpm(+e.target.value)} />
            </div>
          </div>

          <button onClick={resetAll}>Reset</button>

          <div className="divider"></div>

          {PHASE_GROUPS.map(g=>{
            const keys=g.keys.filter(k=>cell.uses[k]);
            if(!keys.length) return null;
            return (
              <details key={g.label} open>
                <summary className="label" style={{ fontSize: 14, color: 'var(--ink)' }}>
                  {g.label}
                </summary>

                <div className="stack" style={{ paddingTop: 8 }}>
                  {keys.map(key=>(
                    <div key={key} className="stack">
                      <div className="row" style={{justifyContent:'space-between'}}>
                        <div style={{fontWeight:600,fontSize:14}}>{CHANNEL_LABELS[key]}</div>
                        <label style={{fontSize:12}}>
                          <input type="checkbox" checked={!!ko[key]} onChange={(e)=>setKo({...ko,[key]:e.target.checked})}/> KO
                        </label>
                      </div>
                      <div className="row">
                        <input type="range" min="0" max="200" step="5" disabled={!!ko[key]}
                          value={ko[key]?0:(params[key]??100)}
                          onChange={(e)=>setParams({...params,[key]:+e.target.value})}/>
                        <input type="number" min="0" max="200" step="5" disabled={!!ko[key]}
                          value={ko[key]?0:(params[key]??100)}
                          onChange={(e)=>setParams({...params,[key]:clamp(+e.target.value||0,0,200)})}/>
                        <span style={{color:'#64748b'}}>{ko[key]?0:(params[key]??100)}%</span>
                      </div>
                    </div>
                  ))}
                </div>
              </details>
            );
          })}

          <label style={{fontSize:12}}>
            <input type="checkbox" checked={showBaseline} onChange={(e)=>setShowBaseline(e.target.checked)} /> Show baseline
          </label>
        </div>
      </section>

      {/* AP chart + metrics */}
      <section className="section">
        <h2>Action Potential</h2>
        <div className="legend">
          <span className="pill"><span className="line"></span> Modified</span>
          <span className="pill"><span className="dash"></span> Baseline</span>
        </div>
        <div style={{width:'100%'}}>
          <ResponsiveContainer width="100%" height={420}>
            <LineChart data={modified} margin={{top:8,right:40,bottom:20,left:20}}>
              <CartesianGrid strokeDasharray="3 3"/>
              <XAxis type="number" dataKey="t" domain={[0,'dataMax']} tickCount={10} label={xAxisLabel}/>
              <YAxis domain={[-100,50]} tickCount={8} label={yAxisLabel}/>
              <Tooltip formatter={(v)=>`${Number(v).toFixed(1)} mV`} labelFormatter={(l)=>`${Number(l).toFixed(1)} ms`} />
              {showBaseline && (
                <Line dot={false} type="monotone" dataKey="v" data={baseline}
                      name="Baseline" stroke="#94a3b8" strokeWidth={2} strokeDasharray="6 4"/>
              )}
              <Line dot={false} type="monotone" dataKey="v" data={modified}
                    name="Modified" stroke="#0f172a" strokeWidth={3}/>
              <ReferenceLine y={-85} stroke="#e5e7eb"/>
            </LineChart>
          </ResponsiveContainer>
        </div>

      <div className="metrics" style={{marginTop:12}}>
        <div className="metric">
          <div className="k">APD90</div>
          <div className="v">{curMetrics.apd90} ms</div>
          <div className="d" style={{color:(curMetrics.apd90-baseMetrics.apd90)>=0?'var(--green)':'var(--red)'}}>
            {(curMetrics.apd90-baseMetrics.apd90)>=0?'↑':'↓'} {Math.abs(curMetrics.apd90-baseMetrics.apd90)} vs baseline
          </div>
        </div>
        <div className="metric">
          <div className="k">dV/dt_max</div>
          <div className="v">{curMetrics.dvdtMax} mV/ms</div>
          <div className="d" style={{color:(curMetrics.dvdtMax-baseMetrics.dvdtMax)>=0?'var(--green)':'var(--red)'}}>
            {(curMetrics.dvdtMax-baseMetrics.dvdtMax)>=0?'↑':'↓'} {Math.abs((curMetrics.dvdtMax-baseMetrics.dvdtMax).toFixed(2))} vs baseline
          </div>
        </div>
        <div className="metric">
          <div className="k">Cycle</div>
          <div className="v">{curMetrics.cycle} ms</div>
          <div className="d" style={{color:(curMetrics.cycle-baseMetrics.cycle)>=0?'var(--green)':'var(--red)'}}>
            {(curMetrics.cycle-baseMetrics.cycle)>=0?'↑':'↓'} {Math.abs(curMetrics.cycle-baseMetrics.cycle)} vs baseline
          </div>
        </div>
      </div>

      <div className="divider"></div>

      {/* ECG with baseline overlay */}
      <h2>ECG (Lead II — synthetic)</h2>
      <div className="legend" style={{marginBottom:0}}>
        <span className="pill"><span className="line"></span> Modified</span>
        <span className="pill"><span className="dash"></span> Baseline</span>
      </div>
      <div style={{width:'100%', marginTop:8}}>
        <ResponsiveContainer width="100%" height={200}>
          <LineChart data={ecgData} margin={{top:8,right:20,bottom:20,left:20}}>
            <CartesianGrid strokeDasharray="3 3" />
            <XAxis type="number" dataKey="t" domain={[0,'dataMax']} tickCount={8}
                   label={{value:'time (s)', position:'insideBottomRight', offset:-10}}/>
            <YAxis domain={[-1.2,1.4]} tickCount={5}
                   label={{value:'mV', angle:-90, position:'insideLeft'}}/>
            <Tooltip formatter={(v)=>`${Number(v).toFixed(2)} mV`} labelFormatter={(l)=>`${Number(l).toFixed(2)} s`} />
            {showBaseline && (
              <Line dot={false} type="monotone" dataKey="v" data={ecgBaseline}
                    name="ECG Baseline" stroke="#94a3b8" strokeWidth={2} strokeDasharray="6 4"/>
            )}
            <Line dot={false} type="monotone" dataKey="v" data={ecgData}
                  name="ECG Modified" stroke="#0f172a" strokeWidth={2.5}/>
          </LineChart>
        </ResponsiveContainer>
      </div>

      </section>
    </div>
  );
}

/* ---------------- Main App ---------------- */
function App(){
  const [mode, setMode] = useState('explore');
  return (
    <>
      <div className="mode-toggle">
        <button className={mode==='explore'?'active':''} onClick={()=>setMode('explore')}>Explore Mode</button>
        <button className={mode==='quiz'?'active':''} onClick={()=>setMode('quiz')}>Quiz Mode</button>
      </div>
      {mode==='explore' ? <ExploreMode/> : <QuizMode/>}
    </>
  );
}
ReactDOM.createRoot(document.getElementById('ap-app')).render(<App/>);
</script>
{% endraw %}
