---
layout: default
title: Cardio Physio
---

<div id="ap-app" style="max-width:1400px;margin:0 auto;padding:1.25rem"></div>

<!-- React + ReactDOM (UMD) -->
<script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

<script crossorigin src="https://unpkg.com/react-is@18/umd/react-is.development.js"></script>

<!-- Recharts (UMD) -->
<script crossorigin src="https://unpkg.com/recharts/umd/Recharts.js"></script>

<!-- Babel (compile JSX in the browser) -->
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

<style>
  :root{--ink:#0f172a;--muted:#64748b;--grid:#e5e7eb;--green:#059669;--red:#dc2626;--blue:#2563eb;}
  body{color:var(--ink)}
  .wrap{display:grid;grid-template-columns:1fr;gap:24px;max-width:100%;}
  @media(min-width:1024px){.wrap{grid-template-columns:minmax(300px, 400px) 1fr;gap:32px}}
  .section h2{font:600 12px/1.1 ui-sans-serif,system-ui;letter-spacing:.08em;text-transform:uppercase;color:var(--muted);margin:0 0 8px}
  .stack{display:flex;flex-direction:column;gap:12px}
  .row{display:flex;gap:12px;align-items:center}
  .flex1{flex:1}
  .field{display:flex;flex-direction:column;gap:6px}
  .label{font-size:12px;color:var(--muted)}
  input[type="range"]{width:100%}
  input[type="number"],select,button{border:1px solid var(--grid);border-radius:6px;padding:6px 8px;font-size:14px}
  button{cursor:pointer;background:#fff}
  button:hover{background:#f8fafc}
  button.primary{background:var(--blue);color:white;font-weight:600}
  button.primary:hover{background:#1d4ed8}
  .legend{display:flex;gap:16px;align-items:center;margin:6px 0 10px;font-size:14px}
  .pill{display:inline-flex;gap:8px;align-items:center}
  .pill .line{width:32px;height:2px;background:var(--ink);display:inline-block}
  .pill .dash{width:32px;height:0;border-top:2px dashed #94a3b8;display:inline-block}
  .metrics{display:grid;grid-template-columns:repeat(3,1fr);gap:12px}
  .metric .k{color:var(--muted);font-size:12px}
  .metric .v{font-weight:600}
  .metric .d{font-size:12px}
  .divider{height:1px;background:var(--grid);margin:12px 0}
  .mode-toggle{display:flex;gap:0;border:1px solid var(--grid);border-radius:6px;overflow:hidden;margin-bottom:16px}
  .mode-toggle button{border:none;border-radius:0;padding:8px 16px;background:white}
  .mode-toggle button.active{background:var(--blue);color:white}
  .quiz-option{padding:12px;border:2px solid var(--grid);border-radius:6px;cursor:pointer;transition:all 0.2s}
  .quiz-option:hover{border-color:var(--blue);background:#f8fafc}
  .quiz-option.correct{border-color:var(--green);background:#f0fdf4}
  .quiz-option.incorrect{border-color:var(--red);background:#fef2f2}
  .quiz-option.disabled{cursor:not-allowed;opacity:0.6}
  .score-display{display:flex;gap:16px;padding:12px;background:#f8fafc;border-radius:6px;font-weight:600}
  .badge{display:inline-block;padding:4px 8px;border-radius:4px;font-size:12px;font-weight:600;margin-left:8px}
  .badge.ko{background:#fef2f2;color:var(--red)}
  .badge.increase{background:#f0fdf4;color:var(--green)}
</style>

{% raw %}
<script type="text/babel" data-presets="env,react">
const {useMemo,useState,Fragment,useRef} = React;
const {LineChart,Line,CartesianGrid,XAxis,YAxis,Tooltip,ReferenceLine,ResponsiveContainer} = Recharts;

/* ---------------- Model constants ---------------- */
const BASELINE_PARAMS = { INa:100, ICaL:100, Ito:100, IKr:100, IKs:100, IK1:100, If:100, ICaT:100, IK_ACh:100, NaKATPase:100 };
const CHANNEL_LABELS = {
  INa:"I_Na (fast Na⁺)", ICaL:"I_CaL (L-type Ca²⁺)", Ito:"I_to (transient outward K⁺)",
  IKr:"I_Kr (rapid delayed rectifier K⁺)", IKs:"I_Ks (slow delayed rectifier K⁺)", IK1:"I_K1 (inward rectifier K⁺)",
  If:"I_f (funny)", ICaT:"I_CaT (T-type Ca²⁺)", IK_ACh:"I_K,ACh", NaKATPase:"Na⁺/K⁺-ATPase"
};

// Channels that have similar effects when modified
const SIMILAR_CHANNEL_GROUPS = [
  ['IKr', 'IKs'], // Both delayed rectifier K+ channels
  ['ICaL', 'ICaT'], // Both Ca2+ channels
  ['If', 'ICaT'], // Both contribute to pacemaker activity
];

const CELL_TYPES = [
  { id:"ventricular", name:"Ventricular Myocyte", uses:{INa:1,ICaL:1,Ito:1,IKr:1,IKs:1,IK1:1,If:0,ICaT:0,IK_ACh:0,NaKATPase:1}},
  { id:"atrial", name:"Atrial Myocyte", uses:{INa:1,ICaL:1,Ito:1,IKr:1,IKs:1,IK1:1,If:0,ICaT:0,IK_ACh:1,NaKATPase:1}},
  { id:"sa", name:"SA Node (Pacemaker)", uses:{INa:0,ICaL:1,Ito:0,IKr:1,IKs:1,IK1:1,If:1,ICaT:1,IK_ACh:1,NaKATPase:1}},
  { id:"purkinje", name:"Purkinje Cell", uses:{INa:1,ICaL:1,Ito:1,IKr:1,IKs:1,IK1:1,If:1,ICaT:1,IK_ACh:0,NaKATPase:1}},
];
const DRUG_PRESETS = {
  "None":{}, "Lidocaine":{INa:50}, "Tetrodotoxin":{INa:5}, "Ranolazine":{INa:70}, "Quinine":{INa:60},
  "Verapamil":{ICaL:40}, "Nifedipine":{ICaL:50}, "Ivabradine":{If:30}, "Acetylcholine ↑":{IK_ACh:150}, "Ouabain":{NaKATPase:40}
};
const ENV_PRESETS = { "None":{}, "Hypokalemia":{IK1:120,IKr:90,IKs:95}, "Hyperkalemia":{IK1:60,INa:80}, "Ischemia":{NaKATPase:50,IK1:70,IKr:120} };

const clamp=(v,lo,hi)=>Math.max(lo,Math.min(hi,v));
const pct=(x)=>clamp(x/100,0,2);

/* ---------------- AP generator ---------------- */
function generateAP(cellId, params){
  const isPacemaker = cellId==="sa";
  let t0=2,t1=8,t2=180,t3=120,t4=100, vmax=30, vrest=-85;
  const kINa=pct(params.INa), kICaL=pct(params.ICaL), kIto=pct(params.Ito),
        kIKr=pct(params.IKr), kIKs=pct(params.IKs), kIK1=pct(params.IK1),
        kIf=pct(params.If), kICaT=pct(params.ICaT), kIK_ACh=pct(params.IK_ACh), kPump=pct(params.NaKATPase);

  if(isPacemaker){
    // SA-node specific physiology
    t1 = 0; t2 = 0;
    // Phase 0 by ICaL (no fast INa)
    t0   = 15 / clamp(kICaL,0.2,2);
    // modest overshoot; weaker with more outward K+
    const kK = 0.6*kIKr + 0.4*kIKs;
    vmax = 20*kICaL - 5*(kK-1);
    // Phase 3 governed by delayed rectifier K+
    t3 = 150 / clamp(kK,0.2,2);
    // Phase 4 slope: If & ICaT speed; IK,ACh and K+ slow
    const slope = 0.45*kIf + 0.25*kICaT - 0.35*(kIK_ACh-1) - 0.15*(kK-1);
    t4 = clamp(220 / clamp(1+slope,0.2,3), 60, 600);
    // SA MDP baseline around −65 mV, modulated by pump/IK1 and K+ availability
    const vrestBase = -65;
    vrest = vrestBase - 2*(kPump-1) + 2*(1-kIK1) + 6*(1-kK);
  } else {
    t0=clamp(2/clamp(kINa,0.2,2),0.5,6); vmax=30*clamp(kINa,0.4,1.6);
    t1=clamp(8*(0.6+0.4*kIto),2,18);
    const kK=0.6*kIKr+0.4*kIKs; t2=clamp(180*(kICaL/clamp(kK,0.3,2)),40,400);
    t3=clamp(120/clamp(kK,0.3,2),30,300);
    vrest=-85-4*(kPump-1)+5*(1-kIK1);
    if(cellId==="purkinje"){
      const s=0.1*(kIf-1)+0.05*(kICaT-1);
      t4=clamp(100/clamp(1+s,0.3,2),40,300);
    }
  }

  const data=[]; const push=(t,v)=>data.push({t:Math.round(t*10)/10,v});
  const segs=[]; let tA=0; const vTh=isPacemaker?-40:-60;

  // Optional cycle clamp (used only when caller supplies it; not for pacemaker by default)
  if(params && typeof params.__targetCycle==='number'){
    const baseCycle=t4+t0+(isPacemaker?0:(t1+t2))+t3;
    t4=clamp(t4+(params.__targetCycle-baseCycle),20,1200);
  }

  // phase 4
  const n4=Math.max(5,Math.round(t4/2));
  for(let i=0;i<=n4;i++){ const f=i/n4; push(tA+f*t4, vrest+(vTh-vrest)*f); }
  segs.push({phase:4,tStart:tA,tEnd:tA+t4}); tA+=t4;

  // phase 0
  const n0=Math.max(5,Math.round(t0/0.5));
  for(let i=0;i<=n0;i++){ const f=i/n0; push(tA+f*t0, vTh+(vmax-vTh)*(1-Math.pow(1-f,3))); }
  segs.push({phase:0,tStart:tA,tEnd:tA+t0}); tA+=t0;

  if(!isPacemaker){
    // phase 1
    const notch=vmax-20*kIto, n1=Math.max(3,Math.round(t1/0.5));
    for(let i=0;i<=n1;i++){ const f=i/n1; push(tA+f*t1, vmax+(notch-vmax)*f); }
    segs.push({phase:1,tStart:tA,tEnd:tA+t1}); tA+=t1;

    // phase 2
    const plateau=-5+10*(kICaL-(0.6*kIKr+0.4*kIKs)), n2=Math.max(10,Math.round(t2/2));
    for(let i=0;i<=n2;i++){ const f=i/n2; push(tA+f*t2, notch+(plateau-notch)*(1-Math.cos(Math.PI*f))/2); }
    segs.push({phase:2,tStart:tA,tEnd:tA+t2}); tA+=t2;
  }

  // phase 3
  const vEnd=vrest, vStart=isPacemaker? vmax : (data[data.length-1]?.v ?? vmax);
  const n3=Math.max(10,Math.round(t3/2));
  for(let i=0;i<=n3;i++){ const f=i/n3; push(tA+f*t3, vStart+(vEnd-vStart)*(1-Math.cos(Math.PI*f))/2); }
  segs.push({phase:3,tStart:tA,tEnd:tA+t3}); tA+=t3;

  const marks = segs.map(s=>{
    const mid=(s.tStart+s.tEnd)/2; let nearest=data[0];
    for(let i=1;i<data.length;i++){ if(Math.abs(data[i].t-mid)<Math.abs(nearest.t-mid)) nearest=data[i]; }
    return {label:`Phase ${s.phase}`, t:nearest.t, v:nearest.v};
  }).filter(m=>!(cellId==="sa" && (m.label==="Phase 1"||m.label==="Phase 2")));

  return {data, marks, segs};
}

function computeMetrics(curve){
  const pts=curve.data||curve; if(!pts.length) return {apd90:0,dvdtMax:0,cycle:0};
  const vrest=pts[0].v; const vmax=pts.reduce((m,p)=>Math.max(m,p.v),-Infinity);
  const v90=vrest+0.1*(vmax-vrest); const up=pts.findIndex(p=>p.v>v90);
  let down=pts.length-1; for(let i=pts.length-1;i>=0;i--){ if(pts[i].v>v90){ down=i; break; } }
  const apd90=(up>=0 && down>up)?(pts[down].t-pts[up].t):0;
  let dvdtMax=0; for(let i=1;i<pts.length;i++){ const dv=pts[i].v-pts[i-1].v; const dt=pts[i].t-pts[i-1].t||1e-6; dvdtMax=Math.max(dvdtMax,dv/dt); }
  const cycle=pts[pts.length-1].t;
  return {apd90:Math.round(apd90), dvdtMax:Math.round(dvdtMax*100)/100, cycle:Math.round(cycle)};
}

const PHASE_GROUPS=[
  {label:'Phase 0 (Upstroke)', keys:['INa','ICaL']},
  {label:'Phase 1 (Notch)', keys:['Ito']},
  {label:'Phase 2 (Plateau)', keys:['ICaL','IKr','IKs']},
  {label:'Phase 3 (Repolarization)', keys:['IKr','IKs']},
  {label:'Phase 4 (Rest/Diastolic)', keys:['IK1','If','ICaT','IK_ACh','NaKATPase']},
];

// Helper to check if two channels are in the same similarity group
function areSimilarChannels(ch1, ch2){
  for(const group of SIMILAR_CHANNEL_GROUPS){
    if(group.includes(ch1) && group.includes(ch2)) return true;
  }
  return false;
}

/* ---------------- Quiz Component ---------------- */
function QuizMode(){
  const [cellTypeId, setCellTypeId] = useState("ventricular");
  const [currentQuestion, setCurrentQuestion] = useState(null);
  const [selectedAnswer, setSelectedAnswer] = useState(null);
  const [showResult, setShowResult] = useState(false);
  const [score, setScore] = useState(0);
  const [questionsAnswered, setQuestionsAnswered] = useState(0);
  const lastTargetRef = useRef(null);

  const cell = useMemo(()=>CELL_TYPES.find(c=>c.id===cellTypeId)||CELL_TYPES[0],[cellTypeId]);
  const availableChannels = useMemo(()=>Object.keys(CHANNEL_LABELS).filter(k=>cell.uses[k]),[cell]);

  const generateQuestion = ()=>{
    // Pick a target channel that's different from the last one
    let targetChannel;
    const eligibleChannels = availableChannels.filter(ch => ch !== lastTargetRef.current);
    targetChannel = (eligibleChannels.length===0) ? availableChannels[0] : eligibleChannels[Math.floor(Math.random()*eligibleChannels.length)];
    lastTargetRef.current = targetChannel;

    // Randomly decide between knockout (0%) or increase (200%)
    const isKnockout = Math.random() < 0.5;
    const modValue = isKnockout ? 0 : 200;
    const modType = isKnockout ? 'knockout' : 'increase';

    // No cycle clamp here → pacemaker rate can change
    const modParams = {...BASELINE_PARAMS, [targetChannel]:modValue};
    const baselineParams = {...BASELINE_PARAMS};

    // Wrong answers avoiding similar channels
    const wrongAnswers = availableChannels
      .filter(c => c !== targetChannel && !areSimilarChannels(c, targetChannel))
      .sort(()=>Math.random()-0.5)
      .slice(0,3);
    if(wrongAnswers.length < 3){
      const remaining = availableChannels
        .filter(c => c !== targetChannel && !wrongAnswers.includes(c))
        .sort(()=>Math.random()-0.5);
      wrongAnswers.push(...remaining.slice(0, 3 - wrongAnswers.length));
    }
    const allOptions = [targetChannel, ...wrongAnswers].sort(()=>Math.random()-0.5);

    return {
      targetChannel,
      modType,
      modValue,
      modParams,
      baselineParams,
      options: allOptions,
      baseline: generateAP(cellTypeId, baselineParams),
      modified: generateAP(cellTypeId, modParams)
    };
  };

  useMemo(()=>{
    if(!currentQuestion) setCurrentQuestion(generateQuestion());
  },[cellTypeId, currentQuestion, availableChannels]);

  const handleAnswer = (answer)=>{
    if(showResult) return;
    setSelectedAnswer(answer);
    setShowResult(true);
    setQuestionsAnswered(q=>q+1);
    if(answer === currentQuestion.targetChannel){
      setScore(s=>s+1);
    }
  };

  const nextQuestion = ()=>{
    setCurrentQuestion(generateQuestion());
    setSelectedAnswer(null);
    setShowResult(false);
  };

  const resetQuiz = ()=>{
    setScore(0);
    setQuestionsAnswered(0);
    lastTargetRef.current = null;
    setCurrentQuestion(generateQuestion());
    setSelectedAnswer(null);
    setShowResult(false);
  };

  if(!currentQuestion) return <div>Loading...</div>;

  const xAxisLabel={ value:'time (ms)', position:'insideBottomRight', offset:-10 };
  const yAxisLabel={ value:'membrane potential (mV)', angle:-90, position:'insideLeft' };

  return (
    <div className="wrap">
      <section className="section">
        <h2>Quiz Settings</h2>
        <div className="stack">
          <div className="field">
            <label className="label">Cell type</label>
            <select value={cellTypeId} onChange={(e)=>{setCellTypeId(e.target.value);lastTargetRef.current=null;setCurrentQuestion(null);}} disabled={showResult}>
              {CELL_TYPES.map(c=><option key={c.id} value={c.id}>{c.name}</option>)}
            </select>
          </div>
          
          <div className="divider"></div>
          
          <div className="score-display">
            <div>Score: {score}/{questionsAnswered}</div>
            <div>{questionsAnswered>0 ? `${Math.round(score/questionsAnswered*100)}%` : '—'}</div>
          </div>

          <button onClick={resetQuiz}>Reset Quiz</button>

          <div className="divider"></div>

          <div>
            <h3 style={{marginBottom:12,fontSize:14,fontWeight:600}}>
              Which ion channel/transporter was 
              <span className={`badge ${currentQuestion.modType==='knockout'?'ko':'increase'}`}>
                {currentQuestion.modType==='knockout' ? 'KNOCKED OUT (0%)' : 'INCREASED (200%)'}
              </span>
              ?
            </h3>
            <div className="stack">
              {currentQuestion.options.map(opt=>(
                <button 
                  key={opt}
                  className={`quiz-option ${showResult ? (opt===currentQuestion.targetChannel ? 'correct' : opt===selectedAnswer ? 'incorrect' : '') : ''} ${showResult ? 'disabled' : ''}`}
                  onClick={()=>handleAnswer(opt)}
                  disabled={showResult}
                >
                  {CHANNEL_LABELS[opt]}
                </button>
              ))}
            </div>
          </div>

          {showResult && (
            <>
              <div style={{padding:12,background:selectedAnswer===currentQuestion.targetChannel?'#f0fdf4':'#fef2f2',borderRadius:6,fontWeight:600}}>
                {selectedAnswer===currentQuestion.targetChannel ? '✓ Correct!' : `✗ Incorrect. The answer was: ${CHANNEL_LABELS[currentQuestion.targetChannel]}`}
              </div>
              <button className="primary" onClick={nextQuestion}>Next Question</button>
            </>
          )}
        </div>
      </section>

      <section className="section">
        <h2>Action Potential</h2>
        <div className="legend">
          <span className="pill"><span className="line"></span> Modified ({currentQuestion.modType})</span>
          <span className="pill"><span className="dash"></span> Baseline</span>
        </div>
        <div style={{width: '100%'}}>
          <ResponsiveContainer width="100%" height={420}>
            <LineChart data={currentQuestion.modified.data} margin={{top:8,right:40,bottom:20,left:20}}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis type="number" dataKey="t" domain={[0,'dataMax']} tickCount={10} label={xAxisLabel}/>
              <YAxis domain={[-100,50]} tickCount={8} label={yAxisLabel}/>
              <Tooltip formatter={(v)=>`${Number(v).toFixed(1)} mV`} labelFormatter={(l)=>`${Number(l).toFixed(1)} ms`} />
              <Line dot={false} type="monotone" dataKey="v" data={currentQuestion.baseline.data} name="Baseline" stroke="#94a3b8" strokeWidth={2} strokeDasharray="6 4"/>
              <Line dot={false} type="monotone" dataKey="v" data={currentQuestion.modified.data} name="Modified" stroke="#0f172a" strokeWidth={3}/>
              <ReferenceLine y={-85} stroke="#e5e7eb"/>
            </LineChart>
          </ResponsiveContainer>
        </div>
      </section>
    </div>
  );
}

/* ---------------- Explore Mode Component ---------------- */
function ExploreMode(){
  const [cellTypeId,setCellTypeId]=useState("ventricular");
  const [params,setParams]=useState({...BASELINE_PARAMS});
  const [ko,setKo]=useState({});
  const [preset,setPreset]=useState("None");
  const [envPreset,setEnvPreset]=useState("None");
  const [showBaseline,setShowBaseline]=useState(true);
  const [bpm,setBpm]=useState(60);

  const cell=useMemo(()=>CELL_TYPES.find(c=>c.id===cellTypeId)||CELL_TYPES[0],[cellTypeId]);

  const workingParams=useMemo(()=>{
    const apply=(base, map)=>{ const out={...base}; Object.entries(map).forEach(([k,v])=>{ if(k in out) out[k]=Math.round(out[k]*(v/100));}); return out; }
    const env=apply(params, ENV_PRESETS[envPreset]||{});
    const drug=apply(env, DRUG_PRESETS[preset]||{});
    const out={...drug};
    Object.keys(ko).forEach(k=>{ if(ko[k]) out[k]=0; });
    Object.keys(out).forEach(k=>{ if(!cell.uses[k]) out[k]=0; });
    // Only clamp cycle for non-pacemaker cells
    if(cell.id!=='sa' && cell.id!=='purkinje'){
      out.__targetCycle = clamp(60000/Math.max(20,Math.min(220,bpm)),250,3000);
    }
    return out;
  },[params,preset,envPreset,ko,cell,bpm]);

  const baseline=useMemo(()=>{
    const base={...BASELINE_PARAMS};
    if(cell.id!=='sa' && cell.id!=='purkinje'){
      base.__targetCycle = 60000/bpm;
    }
    return generateAP(cell.id, base);
  },[cell.id,bpm]);

  const modified=useMemo(()=>generateAP(cell.id,workingParams),[cell.id,workingParams]);
  const baseMetrics=useMemo(()=>computeMetrics(baseline),[baseline]);
  const curMetrics=useMemo(()=>computeMetrics(modified),[modified]);

  const channelOrder=Object.keys(CHANNEL_LABELS).filter(k=>cell.uses[k]);

  const xAxisLabel={ value:'time (ms)', position:'insideBottomRight', offset:-10 };
  const yAxisLabel={ value:'membrane potential (mV)', angle:-90, position:'insideLeft' };

  function resetAll(){ setParams({...BASELINE_PARAMS}); setKo({}); setPreset("None"); setEnvPreset("None"); setBpm(60); }

  return (
    <div className="wrap">
      {/* Controls */}
      <section className="section">
        <h2>Controls</h2>
        <div className="stack">
          <div className="row">
            <div className="field flex1">
              <label className="label">Cell type</label>
              <select value={cellTypeId} onChange={(e)=>setCellTypeId(e.target.value)}>
                {CELL_TYPES.map(c=><option key={c.id} value={c.id}>{c.name}</option>)}
              </select>
            </div>
            <div className="field flex1">
              <label className="label">Drug preset</label>
              <select value={preset} onChange={(e)=>setPreset(e.target.value)}>
                {Object.keys(DRUG_PRESETS).map(p=><option key={p} value={p}>{p}</option>)}
              </select>
            </div>
          </div>
          <div className="row">
            <div className="field flex1">
              <label className="label">Environment</label>
              <select value={envPreset} onChange={(e)=>setEnvPreset(e.target.value)}>
                {Object.keys(ENV_PRESETS).map(p=><option key={p} value={p}>{p}</option>)}
              </select>
            </div>
            <div className="field flex1">
              <label className="label">Pacing (BPM): {bpm}</label>
              <input type="range" min="20" max="220" step="1" value={bpm} onChange={(e)=>setBpm(+e.target.value)} />
            </div>
          </div>

          <button onClick={resetAll}>Reset</button>

          <div className="divider"></div>

          {PHASE_GROUPS.map(g=>{
            const keys=g.keys.filter(k=>cell.uses[k]);
            if(!keys.length) return null;
            return (
              <details key={g.label} open>
                <summary className="label" style={{ fontSize: 14, color: 'var(--ink)' }}>
                  {g.label}
                </summary>

                <div className="stack" style={{ paddingTop: 8 }}>
                  {keys.map(key=>(
                    <div key={key} className="stack">
                      <div className="row" style={{justifyContent:'space-between'}}>
                        <div style={{fontWeight:600,fontSize:14}}>{CHANNEL_LABELS[key]}</div>
                        <label style={{fontSize:12}}>
                          <input type="checkbox" checked={!!ko[key]} onChange={(e)=>setKo({...ko,[key]:e.target.checked})}/> KO
                        </label>
                      </div>
                      <div className="row">
                        <input type="range" min="0" max="200" step="5" disabled={!!ko[key]}
                          value={ko[key]?0:(params[key]??100)}
                          onChange={(e)=>setParams({...params,[key]:+e.target.value})}/>
                        <input type="number" min="0" max="200" step="5" disabled={!!ko[key]}
                          value={ko[key]?0:(params[key]??100)}
                          onChange={(e)=>setParams({...params,[key]:clamp(+e.target.value||0,0,200)})}/>
                        <span style={{color:'#64748b'}}>{ko[key]?0:(params[key]??100)}%</span>
                      </div>
                    </div>
                  ))}
                </div>
              </details>
            );
          })}

          <label style={{fontSize:12}}>
            <input type="checkbox" checked={showBaseline} onChange={(e)=>setShowBaseline(e.target.checked)} /> Show baseline
          </label>
        </div>
      </section>

      {/* Chart + Metrics */}
      <section className="section">
        <h2>Action Potential</h2>
        <div className="legend">
          <span className="pill"><span className="line"></span> Modified</span>
          <span className="pill"><span className="dash"></span> Baseline</span>
        </div>
        <div style={{width: '100%'}}>
          <ResponsiveContainer width="100%" height={420}>
            <LineChart data={modified.data} margin={{top:8,right:40,bottom:20,left:20}}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis type="number" dataKey="t" domain={[0,'dataMax']} tickCount={10} label={xAxisLabel}/>
              <YAxis domain={[-100,50]} tickCount={8} label={yAxisLabel}/>
              <Tooltip formatter={(v)=>`${Number(v).toFixed(1)} mV`} labelFormatter={(l)=>`${Number(l).toFixed(1)} ms`} />
              {showBaseline && (
                <Line dot={false} type="monotone" dataKey="v" data={baseline.data} name="Baseline" stroke="#94a3b8" strokeWidth={2} strokeDasharray="6 4"/>
              )}
              <Line dot={false} type="monotone" dataKey="v" data={modified.data} name="Modified" stroke="#0f172a" strokeWidth={3}/>
              <ReferenceLine y={-85} stroke="#e5e7eb"/>
            </LineChart>
          </ResponsiveContainer>
        </div>

        <div className="metrics" style={{marginTop:12}}>
          <div className="metric">
            <div className="k">APD90</div>
            <div className="v">{curMetrics.apd90} ms</div>
            <div className="d" style={{color:(curMetrics.apd90-baseMetrics.apd90)>=0?'var(--green)':'var(--red)'}}>
              {(curMetrics.apd90-baseMetrics.apd90)>=0?'↑':'↓'} {Math.abs(curMetrics.apd90-baseMetrics.apd90)} vs baseline
            </div>
          </div>
          <div className="metric">
            <div className="k">dV/dt_max</div>
            <div className="v">{curMetrics.dvdtMax} mV/ms</div>
            <div className="d" style={{color:(curMetrics.dvdtMax-baseMetrics.dvdtMax)>=0?'var(--green)':'var(--red)'}}>
              {(curMetrics.dvdtMax-baseMetrics.dvdtMax)>=0?'↑':'↓'} {Math.abs((curMetrics.dvdtMax-baseMetrics.dvdtMax).toFixed(2))} vs baseline
            </div>
          </div>
          <div className="metric">
            <div className="k">Cycle</div>
            <div className="v">{curMetrics.cycle} ms</div>
            <div className="d" style={{color:(curMetrics.cycle-baseMetrics.cycle)>=0?'var(--green)':'var(--red)'}}>
              {(curMetrics.cycle-baseMetrics.cycle)>=0?'↑':'↓'} {Math.abs(curMetrics.cycle-baseMetrics.cycle)} vs baseline
            </div>
          </div>
        </div>

        <div className="divider"></div>

        {/* Sensitivity mini-panel */}
        <div className="stack">
          {channelOrder.map(k=>{
            const apply=(base,map)=>{ const out={...base}; Object.entries(map).forEach(([kk,v])=>{ if(kk in out) out[kk]=Math.round(out[kk]*(v/100));}); return out; };
            const env=apply(params,ENV_PRESETS[envPreset]||{}); const drug=apply(env,DRUG_PRESETS[preset]||{});
            const common={...drug};
            Object.keys(ko).forEach(x=>{ if(ko[x]) common[x]=0; });
            // Clamp only for non-pacemaker types
            if(cellTypeId!=='sa' && cellTypeId!=='purkinje'){
              common.__targetCycle=60000/Math.max(20,Math.min(220,bpm));
            }
            const metrics=p=>computeMetrics(generateAP(cellTypeId,p));
            const m0=metrics(common);
            const up=metrics({...common,[k]:clamp((common[k]??100)*1.2,0,200)});
            const dn=metrics({...common,[k]:clamp((common[k]??100)*0.8,0,200)});
            const dUp=up.apd90-m0.apd90, dDn=dn.apd90-m0.apd90;
            return (
              <div key={k} className="row" style={{alignItems:'center'}}>
                <div style={{width:220,whiteSpace:'nowrap',overflow:'hidden',textOverflow:'ellipsis'}}>{CHANNEL_LABELS[k]}</div>
                <div style={{flex:1,height:8,background:'#f1f5f9',borderRadius:4,position:'relative',overflow:'hidden'}}>
                  <div style={{position:'absolute',left:'50%',top:0,bottom:0,width:1,background:'#cbd5e1'}}></div>
                  <div style={{width:Math.min(100,Math.abs(dDn))+'%', background:dDn<0?'var(--green)':'var(--red)', height:'100%'}}></div>
                  <div style={{marginLeft:'50%', width:Math.min(100,Math.abs(dUp))+'%', background:dUp>0?'var(--green)':'var(--red)', height:'100%'}}></div>
                </div>
                <div style={{width:230,textAlign:'right',fontFeatureSettings:'tnum'}}>
                  ΔAPD: −20% {Math.round(dDn)} / +20% {Math.round(dUp)} ms
                </div>
              </div>
            );
          })}
        </div>
      </section>
    </div>
  );
}

/* ---------------- Main App ---------------- */
function App(){
  const [mode, setMode] = useState('explore');

  return (
    <>
      <div className="mode-toggle">
        <button className={mode==='explore'?'active':''} onClick={()=>setMode('explore')}>Explore Mode</button>
        <button className={mode==='quiz'?'active':''} onClick={()=>setMode('quiz')}>Quiz Mode</button>
      </div>
      {mode==='explore' ? <ExploreMode/> : <QuizMode/>}
    </>
  );
}

ReactDOM.createRoot(document.getElementById('ap-app')).render(<App/>);
</script>
{% endraw %}
